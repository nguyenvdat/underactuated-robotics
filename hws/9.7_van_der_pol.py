# -*- coding: utf-8 -*-
"""van_der_pol.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/RussTedrake/underactuated/blob/master/exercises/lyapunov/van_der_pol/van_der_pol.ipynb

# ROA Estimation for the Time-Reversed Van der Pol Oscillator

## Notebook Setup 
The following cell will install Drake, checkout the underactuated repository, and set up the path (only if necessary).
- On Google's Colaboratory, this **will take approximately two minutes** on the first time it runs (to provision the machine), but should only need to reinstall once every 12 hours.  Colab will ask you to "Reset all runtimes"; say no to save yourself the reinstall.
- On Binder, the machines should already be provisioned by the time you can run this; it should return (almost) instantly.

More details are available [here](http://underactuated.mit.edu/underactuated.html?chapter=drake).
"""

try:
    import pydrake
    import underactuated
except ImportError:
    !curl -s https://raw.githubusercontent.com/RussTedrake/underactuated/master/scripts/setup/jupyter_setup.py > jupyter_setup.py
    from jupyter_setup import setup_underactuated
    setup_underactuated()

# Setup matplotlib.
from IPython import get_ipython
if get_ipython() is not None: get_ipython().run_line_magic("matplotlib", "inline")

# python libraries
import numpy as np
from matplotlib import pyplot as plt

# pydrake imports
from pydrake.all import (LinearQuadraticRegulator, MathematicalProgram, Variables,
                         Solve, RealContinuousLyapunovEquation)
from pydrake.examples.van_der_pol import VanDerPolOscillator

# underactuated imports
from underactuated import plot_2d_phase_portrait

# increase default size matplotlib figures
from matplotlib import rcParams
rcParams['figure.figsize'] = (6, 6)

"""## Problem Description
In this notebook we will study the time-reversed Van der Pol oscillator.
The equations of motion for this system are polynomial, and read as follows:
\begin{align}
\dot x_1 &= - x_2, \\
\dot x_2 &= x_1 + (x_1^2 - 1) x_2.
\end{align}
We compactly represent the latter as $\dot{\mathbf{x}} = f(\mathbf{x})$, with $\mathbf{x} = [x_1, x_2]^T$.
"""

# function that implements the time-reversed Van der Pol dynamics
f = lambda x: [- x[1], x[0] + (x[0]**2 - 1) * x[1]]

"""Here is the phase portrait of the time-reversed Van der Pol oscillator.

As you can see, the origin of this system is locally asymptotically stable whereas, outside the Region Of Attraction (ROA) of the origin, the trajectories escape to infinity.
The boundary of the ROA is an *unstable periodic orbit*:
if the system state at time $t=0$ is exactly on this curve, the oscillator will orbit around the origin forever.
However, any disturbance will make the system either converge to the origin or escape to infinity.
Notice that the shape of this ROA is nontrivial (it is not even a convex set) and no analytic description of it is available.

**Note:**
Reversing the sign of $f$, we obtain the [classical Van der Pol oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator); for which the above periodic orbit is a (globally) asymptotically stable [limit cycle](http://underactuated.mit.edu/simple_legs.html#section1) and the origin is an unstable equilibrium.
Here we reverse time (i.e. change the sign of $f$) to make the origin a stable equilibrium.
"""

# compute and plot the unstable periodic orbit
limit_cycle = VanDerPolOscillator.CalcLimitCycle()
plt.plot(limit_cycle[0], limit_cycle[1], color='b', linewidth=3, label='ROA boundary')
plt.legend(loc=1)

# plot the phase portrait
xlim = (-3, 3)
plot_2d_phase_portrait(f, x1lim=xlim, x2lim=xlim)

"""In this notebook we will use Sums-Of-Squares (SOS) optimization to find an inner approximation of the ROA of the equilibrium point in the origin.
We will write three different SOS optimizations, and we will analyze their pros and cons.

## Lyapunov Function via Linearization
The approach we will follow to estimate the ROA of the oscillator is the following:

- We linearize the dynamics $\dot{\mathbf{x}} = f(\mathbf{x})$ around the origin, to get $\dot{\mathbf{x}} = A \mathbf{x}$.

- We solve the Lyapunov equation $$A^T P + P A = - Q$$ to get the matrix $P$, and the Lyapunov function $V(\mathbf{x}) = \mathbf{x}^T P \mathbf{x}$ for the linearized system.

- Lyapunov theory tells us that if $A$ is strictly stable (all its eigenvalues have strictly negative real part) then the origin is a locally asymptotically stable equilibrium point for the nonlinear system $\dot{\mathbf{x}} = f(\mathbf{x})$.
Moreover, a conservative approximation of the ROA can be obtained using the Lyapunov function $V(\mathbf{x})$ derived in the linear analysis.

- We consider the level sets $$L(\rho) = \{ \mathbf{x} : V(\mathbf{x}) \leq \rho \},$$ and we look for the maximum value of $\rho$ such that $$\dot{V}(\mathbf{x}) = \frac{\partial V}{\partial \mathbf{x}} f(\mathbf{x}) = 2 \mathbf{x}^T P f(\mathbf{x}) < 0, \quad \forall \mathbf{x} \in L(\rho)\backslash \{0\}.$$
In words, we try to find the largest level set $L(\rho)$ entirely contained the region of space where $\dot{V}(\mathbf{x})$ is negative.
Lyapunov theory tells us that any trajectory that starts inside such a set will eventually converge to the origin.

We start by deriving $V(\mathbf{x})$.
"""

# linear approximation A x of f(x)
# for x sufficiently close to the origin
# (if you don't see this immediately, do the math!)
A = np.array([[0, -1], [1, -1]])

# rhs of the Lyapunov equation (standard choice)
Q = np.eye(2)

# positive definite matrix of the Lyapunov function
P = RealContinuousLyapunovEquation(A, Q)

"""## Manual Check
The advantage of working in 2D is that we can plot things!
Before starting with complicated optimizations, let us plot $V(\mathbf{x})$ and $\dot{V}(\mathbf{x})$ to get a sense of what we are actually looking for in this analysis.
"""

# function that given rho plots the boundary
# of the the set L(rho) defined above
def plot_V(rho):
    
    # grid of the state space
    x1 = np.linspace(*xlim)
    x2 = np.linspace(*xlim)
    X1, X2 = np.meshgrid(x1, x2)
    
    # function that evaluates V(x) at a given x
    # (looks bad, but it must accept meshgrids)
    eval_V = lambda x: sum(sum(x[i]*x[j]*Pij for j, Pij in enumerate(Pi)) for i, Pi in enumerate(P))
    
    # contour plot with only the rho level set
    cs = plt.contour(X1, X2, eval_V([X1, X2]), levels=[rho], colors='r', linewidths=3, zorder=3)
    
    # misc plot settings
    plt.xlabel(r'$x_1$')
    plt.ylabel(r'$x_2$')
    plt.gca().set_aspect('equal')
    
    # fake plot for legend
    plt.plot(0, 0, color='r', linewidth=3, label=r'$\{ \mathbf{x} : V(\mathbf{x}) = \rho \}$')
    plt.legend()
    
    return cs
    
# function that plots the levels sets of Vdot(x)
def plot_Vdot():
    
    # grid of the state space
    x1 = np.linspace(*xlim)
    x2 = np.linspace(*xlim)
    X1, X2 = np.meshgrid(x1, x2)
    
    # function that evaluates Vdot(x) at a given x
    eval_Vdot = lambda x: 2*sum(sum(x[i]*f(x)[j]*Pij for j, Pij in enumerate(Pi)) for i, Pi in enumerate(P))
    
    # contour plot with only the rho level set
    cs = plt.contour(X1, X2, eval_Vdot([X1, X2]), colors='b', levels=np.linspace(-10, 40, 11))
    plt.gca().clabel(cs, inline=1, fontsize=10)
    
    # misc plot settings
    plt.xlabel(r'$x_1$')
    plt.ylabel(r'$x_2$')
    plt.gca().set_aspect('equal')
    
    # fake plot for legend
    plt.plot(0, 0, color='b', label=r'$\dot{V}(\mathbf{x})$')
    plt.legend()
    
    return cs

"""By playing with the code below, we see that the largest $\rho$ we can find is $\approx 2.3$."""

# tune rho by hand to make it as big as possible
# while staying in the region where Vdot(x) is negative
rho_max = 2.3

# plot Vdot(x) and V(x) = rho
Vdot_cs = plot_Vdot()
V_cs = plot_V(rho_max)

"""Superimposing the level set to the phase portrait, we see that this is a pretty good approximation of the ROA."""

plot_2d_phase_portrait(f, x1lim=xlim, x2lim=xlim)
plot_V(rho_max)
plt.plot(limit_cycle[0], limit_cycle[1], color='b', linewidth=3, label='ROA boundary')
plt.legend(loc=1)

"""Of course, when $\text{dim}(\mathbf{x}) > 2$, a "manual" maximization of $\rho$ has no hope to work.
That's where SOS programming really makes the difference!
The goal of this notebook is to experiment these tools on a case where things can actually be visualized, so that we get a better sense of the power of this technique.

## Method 1: Line-Search on $\rho$
The first method we use to estimate the ROA is the one from the textbook example "[Region of attraction for the one-dimensional cubic system](http://underactuated.mit.edu/lyapunov.html#roa_cubic_system)".
We look for the largest $\rho$ for which there exists a SOS polynomial $\lambda(\mathbf{x})$ such that $$- \dot{V}(\mathbf{x}) - \lambda(\mathbf{x}) (\rho - V(\mathbf{x})) - \epsilon \mathbf{x}^T \mathbf{x} \ \text{is SOS},$$
with $\epsilon$ very small.
This problem cannot be written as a single SOS program, since both the polynomial $\lambda$ and scalar $\rho$ are decision variables, and here they multiply.
Hence we naively solve a sequence of SOS programs with increasing value of $\rho$.

The intuition behind this formulation is the following.
Think of the condition "is SOS" as "$\geq 0$" (actually, the first is sufficient for the second).
Then what we are asking is $- \dot{V}(\mathbf{x}) \geq \lambda(\mathbf{x}) (\rho - V(\mathbf{x})) + \epsilon \mathbf{x}^T \mathbf{x}$.
Inside the level set $L(\rho)$, we have $\rho - V(\mathbf{x}) \geq 0$ and, since $\lambda(\mathbf{x})$ is SOS, $\lambda(\mathbf{x}) (\rho - V(\mathbf{x})) \geq 0$.
Thus the condition above is just sayng that, for all $\mathbf{x}$ in $L(\rho)$, we must have $- \dot{V}(\mathbf{x})\geq \epsilon \mathbf{x}^T \mathbf{x}$, i.e., $\dot{V}(\mathbf{x})$ negative definite.
"""

# function that verifies the condition described above
# for the level set L(rho) for a given rho
def is_verified(rho):
    
    # initialize optimization problem
    # (with Drake there is no need to specify that
    # this is going to be a SOS program!)
    prog = MathematicalProgram()
    
    # SOS indeterminates
    x = prog.NewIndeterminates(2, 'x')
    
    # Lyapunov function
    V = x.dot(P).dot(x)
    V_dot = 2*x.dot(P).dot(f(x))
    
    # degree of the polynomial lambda(x)
    # no need to change it, but if you really want to,
    # keep l_deg even (why?) and do not set l_deg greater than 10
    # (otherwise optimizations will take forever)
    l_deg = 4
    assert l_deg % 2 == 0

    # SOS Lagrange multipliers
    l = prog.NewSosPolynomial(Variables(x), l_deg)[0].ToExpression()
    
    # main condition above
    eps = 1e-3 # do not change
    prog.AddSosConstraint(- V_dot - l * (rho - V) - eps*x.dot(x))
    
    # solve SOS program
    # no objective function in this formulation
    result = Solve(prog)
    
    # return True if feasible, False if infeasible
    return result.is_success()

"""Now that we have the building block of our algorithm, it's your time to write the line search to find the maximum $\rho$ for which the condition described above holds.

Implement the line search in next cell.
Start with `rho = 0`, check if the level set $L(\rho)$ is verified (i.e. the function `is_verified(rho)` returns `True`); if yes, increase `rho` by `rho_step = .01`, if no, assign to the variable `rho_method_1` the maximum verified `rho` you've found with this procedure.
"""

# line-search parameters
rho = 0 # do not modify
rho_step = .01 # do not modify

# implement your line-search here
# modify here
while is_verified(rho+rho_step):
  rho += rho_step

# set the maximum value of rho you've found with line search
rho_method_1 = rho # modify here
    
# print maximum rho
print(f'Method 1 verified rho = {rho_method_1}.')

"""Did this method do a good job in approximating (from below) the maximum $\rho$ we have found by hand?

## Method 2: Single-Shot SOS Program
With the previous formulation we had to solve a sequence of SOS programs, now we consider an equivalent formulation of the SOS problem in which we can directly maximize $\rho$.
In the previous case we wrote a SOS program to check the impication
$$\mathbf{x} \in L(\rho) \Rightarrow \dot{V}(\mathbf{x}) < 0.$$
This, however, can be equivalently stated as
$$\dot{V}(\mathbf{x}) \geq 0 \Rightarrow \mathbf{x} \not\in L(\rho).$$
Expressing $\mathbf{x} \not\in L(\rho)$ as $V(\mathbf{x}) - \rho \geq 0$, it turns out that the latter condition can be verified with a single SOS program.
(Actually, we should say $V(\mathbf{x}) - \rho > 0$, but working with a computer there is no difference.)

The new problem reads as follows.
Find an SOS polynomial $\lambda(\mathbf{x})$ such that
$$V(\mathbf{x}) - \rho - \lambda(\mathbf{x}) \dot{V}(\mathbf{x}) \ \text{is SOS}.$$
In fact, this implies $V(\mathbf{x}) - \rho \geq \lambda(\mathbf{x}) \dot{V}(\mathbf{x})$ and, for all $\mathbf{x}$ where $\dot{V}(\mathbf{x}) \geq 0$, we get $V(\mathbf{x}) - \rho \geq 0$.

Notice that now $\lambda$ does not multiply $\rho$, and we can search over both of them at the same time.
Hence we can ask the optimizer to maximize $\rho$.
There is however an issue with the current problem formulation...

### Not quite there yet...

Do you see anything wrong with the problem formulation we put together so far? What do you think the maximum $\rho$ will be?

As stated so far, the problem will always return $\rho = 0$!
To see why, first notice that for $\rho = \lambda = 0$ the SOS condition above would become $V(\mathbf{x})$ is SOS, which holds since $V(\mathbf{x}) = \mathbf{x}^T P \mathbf{x}$.
Now consider a positive $\rho$.
Since $V(0) = \dot{V} (0) = 0$, evaluating the SOS condition in the origin, we would get $-\rho \geq 0$ which can never hold!

Not everything is lost, we have a neat fix for you.
Certainly, if $V(\mathbf{x}) - \rho$ is nonnegative, so is $\mathbf{x}^T\mathbf{x}(V(\mathbf{x}) - \rho)$.
Hence we consider the SOS condition
$$\mathbf{x}^T\mathbf{x}(V(\mathbf{x}) - \rho) - \lambda(\mathbf{x}) \dot{V}(\mathbf{x}) \ \text{is SOS},$$
with $\lambda(\mathbf{x})$ SOS.
Now the issue in the origin is fixed, since for $\mathbf{x} = 0$, we get "$0$ is SOS", which is always true.
Moreover, where $\mathbf{x}$ is such that $\dot{V}(\mathbf{x}) \geq 0$, the new SOS condition requires $\mathbf{x}^T\mathbf{x}(V(\mathbf{x}) - \rho) \geq 0$ and hence $V(\mathbf{x}) - \rho \geq 0$ as desired.

Now we are good to go!

In the next cell you need to code the SOS program we just described.
We have already set up the problem for you.
You only have to write two lines of code:

- A line where you add the SOS constraint described in the "Not quite there yet..." subsection above.
To do this, use the method `AddSosConstraint` of `MathematicalProgram` (same method we've used in the previous case).

- A line where you set the objective function of the SOS program.
Remember that we'd like to maximize `rho`.
To this end, use the method `AddLinearCost` of `MathematicalProgram`, but notice that writing `prog.AddLinearCost(rho)` the variable `rho` will be *minimized*.
Any idea for a quick workaround?
Hint: it shouldn't take more than one character!
"""

# initialize optimization problem
prog2 = MathematicalProgram()

# SOS indeterminates
x = prog2.NewIndeterminates(2, 'x')

# Lyapunov function
V = x.dot(P).dot(x)
V_dot = 2*x.dot(P).dot(f(x))

# degree of the polynomial lambda(x)
# no need to change it, but if you really want to,
# keep l_deg even and do not set l_deg greater than 10
l_deg = 4
assert l_deg % 2 == 0

# SOS Lagrange multipliers
l = prog2.NewSosPolynomial(Variables(x), l_deg)[0].ToExpression()

# level set as optimization variable
rho = prog2.NewContinuousVariables(1, 'rho')[0]

# write here the SOS condition described in the "Not quite there yet..." section above
prog2.AddSosConstraint(x.dot(x)*(V-rho) - l*V_dot)

# insert here the objective function (maximize rho)
prog2.AddLinearCost(-rho)

# solve program only if the lines above are filled
if len(prog2.GetAllConstraints()) != 0:

    # solve SOS program
    result = Solve(prog2)

    # get maximum rho
    assert result.is_success()
    rho_method_2 = result.GetSolution(rho)

    # print maximum rho
    print(f'Method 2 verified rho = {rho_method_2}.')

"""## Method 3: Smarter Single-Shot SOS Program
The SOS program we just wrote was already a satisfying solution, but it turns out we can do even better!
From the textbook chapter "[Lyapunov analysis with convex optimization](http://underactuated.mit.edu/lyapunov.html#section2)", you know that every SOS constraint brings with it a lot of optimization variables and an SDP constraint.
So, whenever we can, removing redundant SOS requirements is always a good thing to do.

We claim that in the previous formulation we don't need $\lambda(\mathbf{x})$ to be SOS. How is this possible?

We start by noticing that, in a neighborhood of the origin, excluded the origin itself, $\dot{V}(\mathbf{x})$ is strictly negative.
(This because $V(\mathbf{x})$ is a Lyapunov function for the linearized system hence, locally, it works also for the nonlinear system.)

In light of the latter observation, instead of asking that $\dot{V}(\mathbf{x})$ is negative for all $\mathbf{x} \neq 0$ in $L(\rho)$, we can equivalently ask that all the points $\mathbf{x} \neq 0$ where $\dot{V}(\mathbf{x}) = 0$ must be outside the level set $L(\rho)$.
This might take a second to parse!

The latter condition can be enforced exactly as the one above:
$$\mathbf{x}^T\mathbf{x}(V(\mathbf{x}) - \rho) - \lambda(\mathbf{x}) \dot{V}(\mathbf{x}) \ \text{is SOS},$$
but this time we do not require $\lambda(\mathbf{x})$ to be SOS.

Here is the reasoning.
First, notice that this condition implies $\mathbf{x}^T\mathbf{x}(V(\mathbf{x}) - \rho) \geq \lambda(\mathbf{x}) \dot{V}(\mathbf{x})$.
Then, observe that for all $\mathbf{x}$ such that $\dot{V}(\mathbf{x}) = 0$, we get $\mathbf{x}^T\mathbf{x}(V(\mathbf{x}) - \rho) \geq 0$.
This implies $V(\mathbf{x}) - \rho \geq 0$, i.e., $\mathbf{x} \not\in L(\rho)$ as desired.
(As before, no need to care about what happens at the boundary of the level set.)

This trick can make a huge difference when you need to verify high-dimensional systems!

To try this new idea:
- In the following cell, copy and paste the optimization problem you just wrote above for "Method 2". Attention: this time give the name `prog3` to the `MathematicalProgram` you write (important for autograding).

- Substitute the definition of the polynomial $\lambda$ from `l = prog.NewSosPolynomial(Variables(x), l_deg)[0].ToExpression()` to `l = prog.NewFreePolynomial(Variables(x), l_deg).ToExpression()`.

- Run the new SOS program.

- Define the variable `rho_method_3` to be the optimal value of `rho` for this new optimization problem.

If you have done thing correctly, `rho_method_3` should "closely match" `rho_method_2`!
"""

# initialize optimization problem
prog3 = MathematicalProgram()

# SOS indeterminates
x = prog3.NewIndeterminates(2, 'x')

# Lyapunov function
V = x.dot(P).dot(x)
V_dot = 2*x.dot(P).dot(f(x))

# degree of the polynomial lambda(x)
# no need to change it, but if you really want to,
# keep l_deg even and do not set l_deg greater than 10
l_deg = 4
assert l_deg % 2 == 0

# SOS Lagrange multipliers
l = prog3.NewFreePolynomial(Variables(x), l_deg).ToExpression()

# level set as optimization variable
rho = prog3.NewContinuousVariables(1, 'rho')[0]

# write here the SOS condition described in the "Not quite there yet..." section above
prog3.AddSosConstraint(x.dot(x)*(V-rho) - l*V_dot)

# insert here the objective function (maximize rho)
prog3.AddLinearCost(-rho)

# solve program only if the lines above are filled
if len(prog3.GetAllConstraints()) != 0:

    # solve SOS program
    result = Solve(prog3)

    # get maximum rho
    assert result.is_success()
    rho_method_3 = result.GetSolution(rho)

# print maximum rho
print(f'Method 3 verified rho = {rho_method_3}.')

"""## Final Note
More advanced techniques to approximate ROAs are available.
Generally they require some sort of alternation between optimizing over the multiplier $\lambda$ (as we did here) and modifying the shape of the Lyapunov function $V(\mathbf{x})$, e.g., by considering higher-order polynomials (here we stuck to the quadratic one coming from
linear analysis).
The level set $\rho$ is generally kept fixed (e.g. equal to unity) since, when reshaping the Lyapunov function, the optimizer is allowed to scale the range of this function arbitrarily.

Here is an image of SOS in its full glory approximating the ROA of the Van der Pol oscillator.
Impressive, isn't it?!

![figure](https://raw.githubusercontent.com/RussTedrake/underactuated/master/figures/exercises/van_der_pol_roa.png)
(Courtesy of Shen Shen.)

## Autograding

You can check your work by running the following cell:
"""

from underactuated.exercises.lyapunov.van_der_pol.test_van_der_pol import TestVanDerPol
from underactuated.exercises.grader import Grader
Grader.grade_output([TestVanDerPol], [locals()], 'results.json')
Grader.print_test_results('results.json')